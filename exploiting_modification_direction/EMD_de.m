clear; clc; close all;
% 載入原圖和秘密圖片
orig_img = imread('stego.bmp');  
secret_img = imread('simg.bmp');

% 定義參數 
m = 8;  % 修改方向的個數
alpha = 0.1; % 修改強度 

% 將原圖和秘密圖片轉成灰階圖 
orig_img = rgb2gray(orig_img);  
secret_img = rgb2gray(secret_img);   

% 獲取原圖和秘密圖片的高和寬
[row, col] = size(orig_img);  
[row_s, col_s] = size(secret_img);  

% 根據修改方向產生noisy_dir矩陣
noisy_dir = randi([0, 360], [row, col, m]);   

% 隱寫過程
% 遍歷所有像素點
for i = 1:row
    for j = 1:col
        % 獲取目前像素點的m個修改方向         
        dirs = noisy_dir(i, j, :);
        
        % 計算m個方向對應的秘密圖片的像素值總和         
        secret_val = 0;
        for k = 1:m
            dir = dirs(k);
            new_i = i + round(row_s * sind(dir));
            new_j = j + round(col_s * cosd(dir));
            if new_i > 0 && new_i <= row_s && new_j > 0 && new_j <= col_s
                secret_val = secret_val + double(secret_img(new_i, new_j));
            end 
        end
 
        % 根據修改強度和像素值總和修改目前像素點的值
        orig_img(i, j) = orig_img(i, j) + alpha * (secret_val / m);
    end
end 


% 提取過程
% 初始化提取圖片
extract_img = zeros(row_s, col_s);

% 遍歷所有像素點
for i = 1:row
    for j = 1:col
        % 獲取目前像素點的m個修改方向         
        dirs = noisy_dir(i, j, :);    
        
        % 根據m個方向求取像素差值總和
        diff_val = 0;
        for k = 1:m
            dir = dirs(k);         
            new_i = i + round(row_s * sind(dir));
            new_j = j + round(col_s * cosd(dir));
            if new_i > 0 && new_i <= row_s && new_j > 0 && new_j <= col_s
                diff_val = diff_val + (double(orig_img(i, j)) - double(secret_img(new_i, new_j))); 
            end
        end
            
        % 根據像素差值總和還原秘密圖片中的目前像素點          
        extract_img(i, j) = round(orig_img(i, j) - alpha * (diff_val/m));
        
    end 
end   

% 顯示原圖、隱寫圖和提取圖  
figure, subplot(1,3,1), imshow(orig_img), title('Original Image');
subplot(1,3,2), imshow(orig_img), title('Stego Image'); 
subplot(1,3,3), imshow(extract_img);